<?php

namespace App\Modules\AssetVulnerability\Service;

use App\Modules\AssetDiscovery\Entity\Asset;
use App\Modules\ScanManagement\Entity\ScanJob;
use App\Modules\AssetVulnerability\Entity\Vulnerability;
use Doctrine\ORM\EntityManagerInterface;
use Psr\Log\LoggerInterface;
use SimpleXMLElement;

class VulnerabilityImportService
{
    private EntityManagerInterface $em;
    private LoggerInterface $logger;

    public function __construct(EntityManagerInterface $em, LoggerInterface $logger)
    {
        $this->em = $em;
        $this->logger = $logger;
    }

    /**
     * Import vulnerabilities from Nmap XML output.
     *
     * This method will:
     *  - Parse <script id="vulners"> entries (and other scripts)
     *  - Parse <port> -> <script> blocks
     *  - Create/Update Vulnerability entities linked to the Asset and optional ScanJob
     *
     * @param string $xmlFilePath path to the Nmap XML file
     */
    public function importVulnerabilitiesFromNmapXml(string $xmlFilePath, Asset $asset, ScanJob $scanJob): void
    {
        if (!file_exists($xmlFilePath)) {
            $this->logger->error("XML file does not exist: $xmlFilePath");
            return;
        }

        $content = file_get_contents($xmlFilePath);
        if ($content === false || strlen(trim($content)) === 0) {
            $this->logger->error("XML file is empty: $xmlFilePath");
            return;
        }

        // Load XML safely
        libxml_use_internal_errors(true);
        $xml = @simplexml_load_string($content);
        if (!$xml) {
            $this->logger->error("Failed to parse Nmap XML output at: $xmlFilePath");
            foreach (libxml_get_errors() as $err) {
                $this->logger->error((string)$err);
            }
            libxml_clear_errors();
            return;
        }

        $this->logger->info("Parsing Nmap XML and importing vulnerabilities for asset ID {$asset->getId()} (ScanJob {$scanJob->getId()})");

        // 1) Parse <script id="vulners"> under ports -> port and as port scripts (common)
        $this->parsePortScripts($xml, $asset, $scanJob);

        // 2) Parse hostscript / postscript (some scripts report at host level)
        $this->parseHostScripts($xml, $asset, $scanJob);

        // flush persisted vulnerabilities
        $this->em->flush();

        $this->logger->info("Vulnerability import complete for ScanJob {$scanJob->getId()}.");
    }

    private function parsePortScripts(SimpleXMLElement $xml, Asset $asset, ScanJob $scanJob): void
    {
        if (!isset($xml->host)) {
            return;
        }

        foreach ($xml->host as $host) {
            if (!isset($host->ports)) {
                continue;
            }

            foreach ($host->ports->port as $port) {
                $portId  = (string)$port['portid'];
                $protocol = (string)$port['protocol'];

                // Each <port> can have multiple <script> nodes
                if (isset($port->script)) {
                    foreach ($port->script as $script) {
                        $scriptId = (string)$script['id'];
                        $scriptOutput = (string)$script['output'];

                        // If the script element has nested <table> nodes (vulners plugin), process them
                        if (isset($script->table)) {
                            foreach ($script->table as $table) {
                                $this->handleScriptTable($table, $scriptId, $scriptOutput, $asset, $scanJob, $portId, $protocol);
                            }
                        } else {
                            // Generic script output: try to extract CVE ids in the output and create generic vulnerabilities
                            $this->handleScriptOutputGeneric($scriptId, $scriptOutput, $asset, $scanJob, $portId, $protocol);
                        }
                    }
                }
            }
        }
    }

    private function parseHostScripts(SimpleXMLElement $xml, Asset $asset, ScanJob $scanJob): void
    {
        if (!isset($xml->hostscript)) {
            return;
        }

        foreach ($xml->hostscript->script as $script) {
            $scriptId = (string)$script['id'];
            $scriptOutput = (string)$script['output'];

            if (isset($script->table)) {
                foreach ($script->table as $table) {
                    $this->handleScriptTable($table, $scriptId, $scriptOutput, $asset, $scanJob, null, null);
                }
            } else {
                $this->handleScriptOutputGeneric($scriptId, $scriptOutput, $asset, $scanJob, null, null);
            }
        }
    }

    /**
     * Handle a <table> node from NSE output such as vulners which nests <table><elem key="...">... nodes.
     *
     * The $table param is a SimpleXMLElement representing either:
     *  - a top-level table describing vendor/service (e.g. <table key="nginx 1.19.0">)
     *  - or an inner table with <elem key="cvss">, <elem key="id">, etc.
     */
    private function handleScriptTable(SimpleXMLElement $table, string $scriptId, string $scriptOutput, Asset $asset, ScanJob $scanJob, ?string $portId, ?string $protocol): void
    {
        // If this table contains inner tables, iterate inner tables
        if ($table->table) {
            foreach ($table->table as $inner) {
                $this->handleSingleVulnTable($inner, $scriptId, $scriptOutput, $asset, $scanJob, $portId, $protocol);
            }
            return;
        }

        // If no inner table, treat current as single vuln table
        $this->handleSingleVulnTable($table, $scriptId, $scriptOutput, $asset, $scanJob, $portId, $protocol);
    }

    private function handleSingleVulnTable(SimpleXMLElement $vulnTable, string $scriptId, string $scriptOutput, Asset $asset, ScanJob $scanJob, ?string $portId, ?string $protocol): void
    {
        // Convert table of <elem key="...">value</elem> to associative array
        $data = [];
        foreach ($vulnTable->elem as $elem) {
            $key = (string)$elem['key'];
            $value = trim((string)$elem);
            // There can be repeated keys; if so, convert to array
            if (isset($data[$key])) {
                if (!is_array($data[$key])) {
                    $data[$key] = [$data[$key]];
                }
                $data[$key][] = $value;
            } else {
                $data[$key] = $value;
            }
        }

        // Determine ID and CVSS
        $rawId = $data['id'] ?? null;
        $cvssRaw = $data['cvss'] ?? null;
        $cvss = is_numeric($cvssRaw) ? (float)$cvssRaw : null;

        // Prefer CVE if id contains "CVE-"
        $cveId = $this->extractCveFromString($rawId);
        if ($cveId === null && isset($data['id'])) {
            // If no CVE found, use the raw id as the identifier (e.g. NGINX:CVE-..., PACKETSTORM:..., EDB-ID...)
            $cveId = (string)$rawId;
        }

        // Description: try useful fields; fall back to scriptOutput
        $descriptionParts = [];
        if (!empty($data['type'])) {
            $descriptionParts[] = "type: " . $data['type'];
        }
        if (!empty($data['id'])) {
            $descriptionParts[] = "id: " . $data['id'];
        }
        if (!empty($data['cvss'])) {
            $descriptionParts[] = "cvss: " . $data['cvss'];
        }
        if (!empty($scriptOutput)) {
            $descriptionParts[] = "script output: " . $scriptOutput;
        }
        $description = implode(" | ", $descriptionParts) ?: ('Detected by ' . $scriptId);

        // Compute severity from cvss numeric if available
        $severity = $this->mapCvssToSeverity($cvss);

        // Ensure we have an identifier (the Vulnerability.cveId column is required)
        if (empty($cveId)) {
            // generate stable id based on asset + description
            $cveId = 'VULN-' . substr(sha1($asset->getId() . '|' . $description), 0, 12);
        }

        // Avoid duplicates: find by asset + cveId
        $repo = $this->em->getRepository(Vulnerability::class);
        $existing = $repo->findOneBy([
            'asset' => $asset,
            'cveId' => (string)$cveId,
        ]);

        if ($existing) {
            // Optionally update description/severity/discoveredAt if changed
            $updated = false;
            if ($existing->getDescription() !== $description) {
                $existing->setDescription($description);
                $updated = true;
            }
            if ($existing->getSeverity() !== $severity) {
                $existing->setSeverity($severity);
                $updated = true;
            }
            if ($updated) {
                $this->em->persist($existing);
                $this->logger->info("Updated existing vulnerability {$cveId} for asset {$asset->getId()}");
            } else {
                $this->logger->debug("Vulnerability {$cveId} already exists for asset {$asset->getId()}, skipping insert.");
            }
            return;
        }

        // Create new Vulnerability entity
        $v = new Vulnerability();
        $v->setCveId((string)$cveId);
        $v->setDescription($description);
        $v->setSeverity($severity);
        $v->setDiscoveredAt(new \DateTimeImmutable());
        $v->setStatus('Open');
        $v->setAsset($asset);
        $v->setScanJob($scanJob);

        $this->em->persist($v);
        $this->logger->info("Imported vulnerability {$cveId} for asset {$asset->getId()} (severity: {$severity})");
    }

    /**
     * Generic fallback parser for script outputs that don't contain <table> structures
     */
    private function handleScriptOutputGeneric(string $scriptId, string $scriptOutput, Asset $asset, ScanJob $scanJob, ?string $portId, ?string $protocol): void
    {
        if (empty(trim($scriptOutput))) {
            return;
        }

        // Try to find CVE IDs in the script output
        preg_match_all('/(CVE-\d{4}-\d{4,7})/i', $scriptOutput, $cveMatches);
        if (!empty($cveMatches[1])) {
            foreach ($cveMatches[1] as $cve) {
                $cve = strtoupper($cve);
                $repo = $this->em->getRepository(Vulnerability::class);
                $existing = $repo->findOneBy(['asset' => $asset, 'cveId' => $cve]);
                if ($existing) {
                    $this->logger->debug("CVE {$cve} already exists for asset {$asset->getId()}");
                    continue;
                }

                $v = new Vulnerability();
                $v->setCveId($cve);
                $v->setDescription("Detected by script {$scriptId}: " . $scriptOutput);
                // no numeric CVSS available; set severity default
                $v->setSeverity('Medium');
                $v->setDiscoveredAt(new \DateTimeImmutable());
                $v->setStatus('Open');
                $v->setAsset($asset);
                $v->setScanJob($scanJob);

                $this->em->persist($v);
                $this->logger->info("Imported vulnerability {$cve} from script {$scriptId} for asset {$asset->getId()}");
            }
            return;
        }

        // No CVEs found: create a generic vulnerability entry keyed by scriptId+hash
        $identifier = 'VULN-' . substr(sha1($scriptId . '|' . $scriptOutput), 0, 12);
        $repo = $this->em->getRepository(Vulnerability::class);
        $existing = $repo->findOneBy(['asset' => $asset, 'cveId' => $identifier]);
        if ($existing) {
            $this->logger->debug("Generic vulnerability {$identifier} already exists for asset {$asset->getId()}");
            return;
        }

        $v = new Vulnerability();
        $v->setCveId($identifier);
        $v->setDescription("Script {$scriptId}: " . substr($scriptOutput, 0, 1000));
        $v->setSeverity('Low');
        $v->setDiscoveredAt(new \DateTimeImmutable());
        $v->setStatus('Open');
        $v->setAsset($asset);
        $v->setScanJob($scanJob);

        $this->em->persist($v);
        $this->logger->info("Imported generic vulnerability {$identifier} from script {$scriptId} for asset {$asset->getId()}");
    }

    private function extractCveFromString(?string $s): ?string
    {
        if (empty($s)) {
            return null;
        }
        if (preg_match('/(CVE-\d{4}-\d{4,7})/i', $s, $m)) {
            return strtoupper($m[1]);
        }
        return null;
    }

    private function mapCvssToSeverity(?float $cvss): string
    {
        if ($cvss === null) {
            return 'Medium';
        }
        if ($cvss >= 9.0) {
            return 'Critical';
        }
        if ($cvss >= 7.0) {
            return 'High';
        }
        if ($cvss >= 4.0) {
            return 'Medium';
        }
        return 'Low';
    }
}






<?php

namespace App\Modules\VulnerabilityDetection\MessageHandler;

use App\Modules\AssetVulnerability\Entity\Vulnerability;
use App\Modules\VulnerabilityDetection\Message\NiktoScanMessage;
use App\Modules\VulnerabilityDetection\Service\NiktoScanService;
use App\Modules\ScanManagement\Entity\ScanJob;
use Doctrine\ORM\EntityManagerInterface;
use Psr\Log\LoggerInterface;
use Symfony\Component\Messenger\Attribute\AsMessageHandler;

#[AsMessageHandler]
class NiktoScanMessageHandler
{
    private NiktoScanService $niktoScanService;
    private EntityManagerInterface $em;
    private LoggerInterface $logger;

    public function __construct(
        NiktoScanService $niktoScanService,
        EntityManagerInterface $em,
        LoggerInterface $logger
    ) {
        $this->niktoScanService = $niktoScanService;
        $this->em = $em;
        $this->logger = $logger;
    }

    public function __invoke(NiktoScanMessage $message): void
    {
        $scanJob = $this->em->getRepository(ScanJob::class)->find($message->getScanJobId());

        if (!$scanJob) {
            $this->logger->error('NiktoScanMessageHandler: ScanJob not found for ID: ' . $message->getScanJobId());
            return;
        }

        $asset = $scanJob->getAsset();
        if (!$asset) {
            $this->logger->error('NiktoScanMessageHandler: Asset not found for ScanJob ID: ' . $scanJob->getId());
            $scanJob->setStatus('failed');
            $scanJob->setDetails('Asset not found for scan job.');
            $scanJob->setFinishedAt(new \DateTimeImmutable());
            $this->em->flush();
            return;
        }

        // Mark as running
        $scanJob->setStatus('running');
        $scanJob->setStartedAt(new \DateTimeImmutable());
        $this->em->flush();

        try {
            $target = $asset->getUrl() ?: $asset->getIpAddress() ?: $asset->getDomain();
            $this->logger->info(sprintf("Nikto scan started for asset: %s (%s)", $asset->getName(), $target ?? 'unknown'));

            $jsonText = $this->niktoScanService->performScan($asset);
            $decoded = json_decode($jsonText, true);
            if ($decoded === null) {
                throw new \RuntimeException('Failed to decode Nikto JSON output. Raw output: ' . substr($jsonText ?? '', 0, 300));
            }

            $findings = $this->parseNiktoJson($decoded);

            // Persist findings
            foreach ($findings as $f) {
                $criteria = [
                    'asset' => $asset,
                ];

                if (!empty($f['id'])) {
                    $criteria['cveId'] = $f['id'];
                } else {
                    $criteria['description'] = $f['msg'] ?? 'No description';
                }

                $existingVulnerability = $this->em->getRepository(Vulnerability::class)->findOneBy($criteria);

                if (!$existingVulnerability) {
                    $vuln = new Vulnerability();
                    $vuln->setAsset($asset);
                    $vuln->setCveId($f['id'] ?? null);
                    $vuln->setDescription($f['msg'] ?? 'No description');
                    $vuln->setSeverity($f['severity'] ?? 'Medium');
                    $vuln->setStatus('Open');
                    $vuln->setDiscoveredAt(new \DateTimeImmutable());
                    $this->em->persist($vuln);
                }
            }

            // Finalize scan job
            $scanJob->setFinishedAt(new \DateTimeImmutable());
            $scanJob->setStatus('completed');
            $scanJob->setDetails('Found ' . count($findings) . ' vulnerabilities via Nikto');
            $this->em->flush();

            $this->logger->info(sprintf(
                "Nikto scan completed for asset ID %d with %d vulnerabilities.",
                $asset->getId(),
                count($findings)
            ));
        } catch (\Throwable $e) {
            $this->logger->error(sprintf('Nikto scan failed for asset ID %d: %s', $asset->getId() ?? 0, $e->getMessage()));

            // mark failed and persist details
            $scanJob->setStatus('failed');
            $scanJob->setDetails('Nikto error: ' . $e->getMessage());
            $scanJob->setFinishedAt(new \DateTimeImmutable());
            $this->em->flush();

            // rethrow to let Messenger retry if configured
            throw $e;
        }
    }

    private function parseNiktoJson(array $decoded): array
    {
        $results = [];

        foreach ($decoded as $hostData) {
            if (isset($hostData['vulnerabilities']) && is_array($hostData['vulnerabilities'])) {
                foreach ($hostData['vulnerabilities'] as $vuln) {
                    $results[] = [
                        'id' => $vuln['id'] ?? null,
                        'msg' => $vuln['msg'] ?? '',
                        'url' => $vuln['url'] ?? '',
                        'severity' => $this->determineSeverity($vuln['msg'] ?? ''),
                    ];
                }
            }
        }

        return $results;
    }

    private function determineSeverity(string $msg): string
    {
        $msg = strtolower($msg);
        if (str_contains($msg, 'critical') || str_contains($msg, 'vulnerability')) {
            return 'High';
        }
        if (str_contains($msg, 'missing') || str_contains($msg, 'not set')) {
            return 'Medium';
        }
        return 'Low';
    }
}




